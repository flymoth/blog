<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://flymoth.github.io</id>
    <title>flymoth&apos;s blog </title>
    <updated>2020-04-30T03:24:47.684Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://flymoth.github.io"/>
    <link rel="self" href="https://flymoth.github.io/atom.xml"/>
    <subtitle>for dream.</subtitle>
    <logo>https://flymoth.github.io/images/avatar.png</logo>
    <icon>https://flymoth.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, flymoth&apos;s blog </rights>
    <entry>
        <title type="html"><![CDATA[防抖与节流函数的基本实现]]></title>
        <id>https://flymoth.github.io/fang-dou-yu-jie-liu-han-shu-de-ji-ben-shi-xian/</id>
        <link href="https://flymoth.github.io/fang-dou-yu-jie-liu-han-shu-de-ji-ben-shi-xian/">
        </link>
        <updated>2020-04-30T03:10:09.000Z</updated>
        <content type="html"><![CDATA[<p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。<br>
通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p>
<h2 id="节流">节流</h2>
<p>如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。</p>
<pre><code> function throttle(fn, delay,...arguments) {
     let prev = Date.now()
     let args = [...arguments]
     return function () {
         let cur = Date.now()
         if (cur - prev &gt;= delay) {
             fn.call(this, ...args)
             prev = Date.now()
         }
     }
 }
 //demo
 function fn(n) {
    console.log(n)
}
addEventListener('scroll', throttle(fn,1000,1))
</code></pre>
<h3 id="防抖">防抖</h3>
<p>在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms，然后：<br>
如果在200ms内没有再次触发滚动事件，那么就执行函数<br>
如果在200ms内再次触发滚动事件，那么当前的计时取消，重新开始计时<br>
效果：如果短时间内大量触发同一事件，只会执行一次函数。</p>
<pre><code> function debounce(fn, delay, ...arguments) {
     let timer = null
     let args = [...arguments]
     return function () {l
         clearTimeout(timer)
         timer = setTimeout(() =&gt; {
             fn.call(this, ...args)
         }, delay)
     }
 }
 //demo
 function fn(n) {
    console.log(n)
}
addEventListener('scroll', debounce(fn, 1000,2))
</code></pre>
]]></content>
    </entry>
</feed>